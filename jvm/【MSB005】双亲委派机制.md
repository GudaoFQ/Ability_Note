## 双亲委派机制

#### 双亲委派机制说明
> 先从子到父，再由父到子的过程 

![双亲委派机制](../resource/jvm/jvm-class双亲委派机制.jpg)
* 某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载（让父类加载器去内存中去查找需要加载的类，如果在内存中找到了需要加载的类，那就成功返回；如果在内存中没有找到，当前类加载器会将加载任务委托给它的父类），依次递归。最后找到顶级加载器Bootstrap时，还是没有在内存中找到的话，Bootstrap加载器会委托它下一级加载器（Ext）去找到这个class文件，进行加载；如果Ext不能加载的话，Ext加载器也会委托它的下级加载器去找class文件加载，依次递归
    * 注意：加载器先回找它的父加载器去**内存**中查找，直到Bootstrap加载器也没子在内存中找到；此时会向下委托，去找class文件加载，返回；如果最后还是没有找到。就会抛出一个ClassNotFoundException异常。


#### 使用双亲委派机制可以解决的问题
* 安全问题（主要问题）
> 通过双亲委派机制将JDK中的主要类加载到内存中去了，防止了用户写同样的类（做手脚：木马、替换JDK中自带的String类，通过自己写的String类中的方法在用户登陆时候，将账号密码的String字符串信息发送到自己手机上）来替换到JDK中的类文件，但使用双亲委派机制之后了，会看看内存中有没有加载过，加载过直接将内存中的那类返回

* 资源消耗（次要问题）
> 当资源已经加载过一次后，通过双亲委派机制直接去内存中去找，避免了资源重新加载的问题
